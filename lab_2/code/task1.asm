;>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
; 1DT301, Computer Technology I
; Date: 2016-09-15
; Author:
; Student name 1
; Student name 2
;
; Lab number: 1
; Title: How to use the PORTs. Digital input/output. Subroutine call.
;
; Hardware: STK600, CPU ATmega2560
;
; Function: Describe the function of the program, so that you can understand it,
; even if you're viewing this in a year from now!
;
; Input ports: Describe the function of used ports, for example on-board switches
; connected to PORTA.
;
; Output ports: Describe the function of used ports, for example on-board LEDs
; connected to PORTB.
;
; Subroutines: If applicable.
; Included files: m2560def.inc
;
; Other information:
;
; Changes in program: (Description and date)
;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

.include "m2560def.inc"

; Initialize SP, Stack Pointer
ldi r21, HIGH(RAMEND) ; R20 = high part of RAMEND address
out SPH,R21 ; SPH = high part of RAMEND address
ldi R21, low(RAMEND) ; R20 = low part of RAMEND address
out SPL,R21 ; SPL = low part of RAMEND address

;we initialize 
ldi r16, 0xFF ; 
out DDRB, r16 ; we set the DDRB as output

ldi r17, 0x00
out DDRA, r17 ; we set as output

ldi r16, 0xFF ; we load 0b1111 1111 to the register r16
out PORTA,r16 ; we set the PORTA to r16 SO it means that we put each light off

ldi r20, 0b11111110 ;check if we pressed SW0
ldi r19, 0b10111111 ;Turn on light at 0
ldi r22,0x00

loop:	
	in r18, PINA ;we put the coming data received by the PIND(input) to r18 
	cp r20,r18 ; check if r20==r18
	breq ring_counter
	brne johnson_counter
 

ring_counter:
	ldi r18, 0b11111110
	call ring_loop

ring_loop:
	out PORTB, r18 ;we put the value of r18 to PORTB which should turn on the light
	call Delay
	com r18
	LSL r18
	com r18

	;Check if everything is off if true then go to ring counter to make infinite loop
	ldi r24,0xFF
	cp r24, r18
	breq ring_counter
	
	in r19, PINA
	cp r20,r19
	breq johnson_counter

	rjmp ring_loop


rjmp loop ; we go back at the beginning of the infinite loop

johnson_counter : 	
	ldi r19, 0b11111110 ;Turn on light at 0
	ldi r22, 0x00

johnson_loop:
	out PORTB, r19
	LSL r19
	call Delay
	cp r19, r22
	breq johnson

;Check if PINA SW0 has been pressed if yes then it goes to ring counter
	in r18, PINA
	cp r20,r18
	breq ring_counter

	rjmp johnson_loop

rjmp loop ; we go back at the beginning of the infinite loop

johnson : 
	out PORTB, r22
	ldi r22, 0b11111111
	call Delay
	ldi r19,0b10000000

	more_john : 
		out PORTB, r19
		ASR r19
		call Delay 
		cp r19, r22
		breq johnson_counter

;Check if PINA SW0 has been pressed if yes then it goes to ring counter
		in r18, PINA
		cp r20,r18
		breq ring_counter

	rjmp more_john
	 


Delay :
; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html

	ldi  r21, 5
    ldi  r23, 20
    ldi  r24, 175
L1: dec  r24
    brne L1
    dec  r23
    brne L1
    dec  r21
    brne L1
	ret



.include "m2560def.inc"

; Initialize SP, Stack Pointer
ldi r21, HIGH(RAMEND) ; R20 = high part of RAMEND address
out SPH,R21 ; SPH = high part of RAMEND address
ldi R21, low(RAMEND) ; R20 = low part of RAMEND address
out SPL,R21 ; SPL = low part of RAMEND address

;we initialize 
ldi r16, 0xFF ; 
out DDRB, r16 ; we set the DDRB as output

ldi r17, 0x00
out DDRA, r17 ; we set as output

ldi r16, 0xFF ; we load 0b1111 1111 to the register r16
out PORTA,r16 ; we set the PORTA to r16 SO it means that we put each light off

ldi r20, 0b11111110 ;check if we pressed SW0
ldi r19, 0b10111111 ;Turn on light at 0
ldi r22,0x00

loop:	
	in r18, PINA ;we put the coming data received by the PIND(input) to r18 
	cp r20,r18 ; check if r20==r18
	breq ring_counter
	brne johnson_counter
 

ring_counter:
	ldi r18, 0b11111110
	

ring_loop:
	out PORTB, r18 ;we put the value of r18 to PORTB which should turn on the light
	call Delay
	com r18
	LSL r18
	com r18

	;Check if everything is off if true then go to ring counter to make infinite loop
	ldi r24,0xFF
	cp r24, r18
	breq ring_counter
	
	in r19, PINA
	cp r20,r19
	breq johnson_counter

	rjmp ring_loop


rjmp loop ; we go back at the beginning of the infinite loop

johnson_counter : 	
	ldi r19, 0b11111110 ;Turn on light at 0
	ldi r22, 0x00

johnson_loop:
	out PORTB, r19
	LSL r19
	call Delay
	cp r19, r22
	breq johnson

;Check if PINA SW0 has been pressed if yes then it goes to ring counter
	in r18, PINA
	cp r20,r18
	breq ring_counter

	rjmp johnson_loop

rjmp loop ; we go back at the beginning of the infinite loop

johnson : 
	out PORTB, r22
	ldi r22, 0b11111111
	call Delay
	ldi r19,0b10000000

	more_john : 
		out PORTB, r19
		ASR r19
		call Delay 
		cp r19, r22
		breq johnson_counter

;Check if PINA SW0 has been pressed if yes then it goes to ring counter
		in r18, PINA
		cp r20,r18
		breq ring_counter

	rjmp more_john
	 


Delay :
; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html

	ldi  r21, 5
    ldi  r23, 20
    ldi  r24, 175
L1: dec  r24
    brne L1
    dec  r23
    brne L1
    dec  r21
    brne L1
	ret


; Generated by delay loop calculator
; at http://www.bretmulvey.com/avrdelay.html
;
; Delay 4 050 000 cycles
; 500ms at 8.1 MHz

    ldi  r21, 21
    ldi  r23, 140
    ldi  r24, 174
L1: dec  r24
    brne L1
    dec  r23
    brne L1
    dec  r21
    brne L1
    rjmp PC+1
	ret

